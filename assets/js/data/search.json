[ { "title": "39. 组合总和", "url": "/posts/39-combination-sum/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-07 00:59:00 +0000", "snippet": "问题描述给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。示例 1：输入: candidates = [2,3,6,7], target = 7输出: [[7],[2,2,3]]示例 2：输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]]示例 3：输入: candidates = [2], target = 1输出: []示例 4：输入: candidates = [1], target = 1输出: [[1]]示例 5：输入: candidates = [1], target = 2输出: [[1,1]]搜索回溯对于这类寻找所有可行解的题，都可以尝试用「搜索回溯」的方法来解决。实现一class Solution { int n; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { n = candidates.length; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(n==0) return ans; dfs(ans, new ArrayList&lt;&gt;(), candidates, target, 0); return ans; } public void dfs(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] candidates, int target, int index){ if(target&lt;0){ return; } if(target==0){ ans.add(new ArrayList&lt;&gt;(list)); return; } for(int i=index; i&lt;n; i++){ list.add(candidates[i]); dfs(ans, list, candidates, target-candidates[i],i); list.remove(list.size()-1); } }}实现二定义递归函数 dfs(target, combine, idx) 表示当前在 candidates 数组的第 idx 位，还剩 target 要组合，已经组合的列表为 combine。递归的终止条件为 target &lt;= 0 或者 candidates 数组被全部用完。那么在当前的函数中，每次可以选择跳过不用第 idx 个数，即执行 dfs(target, combine, idx + 1)。也可以选择使用第 idx 个数，即执行 dfs(target - candidates[idx], combine, idx)，注意到每个数字可以被无限制重复选取，因此搜索的下标仍为 idx。class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; combine = new ArrayList&lt;Integer&gt;(); dfs(candidates, target, ans, combine, 0); return ans; } public void dfs(int[] candidates, int target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine, int idx) { if (idx == candidates.length) { return; } if (target == 0) { ans.add(new ArrayList&lt;Integer&gt;(combine)); return; } // 直接跳过 dfs(candidates, target, ans, combine, idx + 1); // 选择当前数 if (target - candidates[idx] &gt;= 0) { combine.add(candidates[idx]); dfs(candidates, target - candidates[idx], ans, combine, idx); combine.remove(combine.size() - 1); } }}" }, { "title": "38. 外观数列", "url": "/posts/38-count-and-say/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-07 00:58:00 +0000", "snippet": "问题描述" }, { "title": "37. 解数独", "url": "/posts/37-sudoku-solver/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-07 00:57:00 +0000", "snippet": "问题描述" }, { "title": "36. 有效的数独", "url": "/posts/36-valid-sudoku/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-07 00:56:00 +0000", "snippet": "问题描述" }, { "title": "35. 搜索插入位置", "url": "/posts/35-search-insert-position/", "categories": "LeetCode, 字符串", "tags": "数据结构与算法", "date": "2022-07-07 00:55:00 +0000", "snippet": "问题描述" }, { "title": "34. 在排序数组中查找元素的第一个和最后一个位置", "url": "/posts/34-find-first-and-last-position-of-element-in-sorted-array/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-07 00:54:00 +0000", "snippet": "问题描述给定一个按照【升序排列】的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？示例 1：输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]示例 2：输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]示例 3：输入：nums = [], target = 0输出：[-1,-1]二分查找考虑 target 开始和结束位置，其实要找的就是数组中「第一个等于 target 的位置」（记为 leftIdx）和「第一个大于 target 的位置减一」（记为 rightIdx）。二分查找中，寻找 leftIdx 即为在数组中寻找第一个大于等于 target 的下标，寻找 rightIdx 即为在数组中寻找第一个大于 target 的下标，然后将下标减一。两者的判断条件不同，为了代码的复用，定义 binarySearch(nums, target, lower) 表示在 nums 数组中二分查找 target 的位置，如果 lower 为 true，则查找第一个大于等于 target 的下标，否则查找第一个大于 target 的下标。最后，因为 target 可能不存在数组中，因此需要重新校验得到的两个下标 leftIdx 和 rightIdx，看是否符合条件，如果符合条件就返回 [leftIdx,rightIdx]，不符合就返回 [−1,−1]。class Solution { public int[] searchRange(int[] nums, int target) { int leftIdx = binarySearch(nums, target, true); int rightIdx = binarySearch(nums, target, false)-1; if(leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target){ return new int[]{leftIdx, rightIdx}; } return new int[]{-1,-1}; } public int binarySearch(int[] nums, int target, boolean lower){ int left = 0, right = nums.length-1, ans = nums.length; while(left&lt;=right){ int mid = (left+right)/2; if(nums[mid]&gt;target || (lower &amp;&amp; nums[mid]&gt;=target)){ right = mid - 1; ans = mid; }else{ left = mid + 1; } } return ans; }}复杂度分析 时间复杂度： O(logn) ，其中 n 为数组的长度。二分查找的时间复杂度为O(logn)，一共会执行两次，因此总时间复杂度为 O(logn)。 空间复杂度：O(1) 。只需要常数空间存放若干变量。 " }, { "title": "33. 搜索旋转排序数组", "url": "/posts/33-search-in-rotated-sorted-array/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-07 00:53:00 +0000", "snippet": "问题描述整数数组 nums 按【升序】排列，数组中的【值互不相同】 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。二分查找将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。这启示可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定该如何改变二分查找的上下界，因为能够根据有序的那部分判断出 target 在不在这个部分： 如果 [l, mid - 1] 是有序数组，且 target 的大小满足 ([nums[l],nums[mid])，则应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。 如果 [mid, r] 是有序数组，且 target 的大小满足 (nums[mid+1],nums[r]]，则应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。 为什么要加等号？mid 比较过了，所以绝对不可能相等，但是 start 是有可能的，即整数向下取整的时候 mid 可能与 start 相等，所以需要加。//二分查找class Solution { //数组中的值 互不相同 public int search(int[] nums, int target) { if(nums==null || nums.length==0) return -1; int i=0, j = nums.length-1; while(i&lt;=j){ int mid = (i+j)/2; if(nums[mid]==target){ return mid; }else if(nums[mid]&lt;nums[j]){ //在右半边 //要有等号[1,3] if(nums[mid]&lt;= target &amp;&amp; target&lt;=nums[j]){ i = mid +1; }else{ j = mid -1; } }else{ //在左半边 //要有等号[1,3] if(nums[i]&lt;=target &amp;&amp; target&lt;=nums[mid]){ j = mid -1; }else{ i = mid +1; } } } return -1; }}复杂度分析 时间复杂度： O(logn)，其中 n 为 nums 数组的大小。整个算法时间复杂度即为二分查找的时间复杂度 O(logn)。 空间复杂度： O(1) 。只需要常数级别的空间存放变量。 错误的解法class Solution { public int search(int[] nums, int target) { if(nums==null || nums.length==0) return -1; int l = 0, r = nums.length-1; while(l&lt;=r){ int mid = (l+r)/2; if(nums[mid]==target){ return mid; }else if(nums[l]&lt;nums[mid]){ //🍒 错误：整数向下取整，l 有可能等于 mid。 //左边有序 （判断条件必须是nums[l]&lt;=nums[mid]） //否则 [3,1] target=1 报错，返回-1 if(nums[l]&lt;=target &amp;&amp; target&lt;=nums[mid]){ r = mid-1; }else{ l = mid+1; } }else{ //右边有序 if(nums[mid]&lt;=target &amp;&amp; target&lt;=nums[r]){ l = mid+1; }else{ r = mid-1; } } } return -1; }}" }, { "title": "32. 最长有效括号", "url": "/posts/32-longest-valid-parentheses/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-07 00:52:00 +0000", "snippet": "问题描述给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。示例 1：输入：s = \"(()\"输出：2解释：最长有效括号子串是 \"()\"示例 2：输入：s = \")()())\"输出：4解释：最长有效括号子串是 \"()()\"示例 3：输入：s = \"\"输出：0方法一、动态规划定义 dp[i] 表示以下标 i 字符结尾的最长有效括号的长度。将 dp 数组全部初始化为 0 。显然有效的子串一定以 ‘)’ 结尾，因此可以知道以 ‘(’ 结尾的子串对应的 dp 值必定为 0 ，只需要求解 ‘)’ 在 dp 数组中对应位置的值。从前往后遍历字符串求解 dp 值，每两个字符检查一次： s[i]=‘)’ 且 s[i−1]=‘(’，也就是字符串形如 “……()”，可以推出：dp[i]=dp[i−2]+2 s[i]=‘)’ 且 s[i−1]=‘)’，也就是字符串形如 “……))”，可以推出：第 i-1 位置上的 ‘)’ 对应的有效括号长度为 dp[i−1]，则第 i 个位置的 ‘)’ 对应第 i−dp[i−1]−1 位置上的符号，如果其为右括号则第 i 个位置有效括号为 0。如果 s[i−dp[i−1]−1]=‘(’，那么 dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2，其中 dp[i−dp[i−1]−2] 为第 i−dp[i−1]−1 位置前的有效子串。 class Solution { public int longestValidParentheses(String s) { int maxLen = 0; int[] dp = new int[s.length()]; for(int i=1; i&lt;s.length(); i++){ if(s.charAt(i)==')'){ if(s.charAt(i-1)=='('){ dp[i] = (i&gt;=2 ? dp[i-2] : 0) + 2; }else if(i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1)=='('){ dp[i] = dp[i-1] + 2 + ((i-dp[i-1]-2)&gt;0?dp[i-dp[i-1]-2]:0); } maxLen = Math.max(maxLen, dp[i]); } } return maxLen; }}复杂度分析 时间复杂度：O(n)，其中 n 为字符串的长度。只需遍历整个字符串一次，即可将 dp 数组求出来。 空间复杂度：O(n)。需要一个大小为 n 的 dp 数组。 方法二、不需要额外的空间利用两个计数器 left 和 right 。首先，从左到右遍历字符串，对于遇到的每个 ‘(’，增加 left 计数器，对于遇到的每个 ‘)’ ，增加 right 计数器。每当 left 计数器与 right 计数器相等时，计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 right 计数器比 left 计数器大时，将 left 和 right 计数器同时变回 0。这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。解决的方法也很简单，只需要【从右往左】遍历用类似的方法计算即可，只是这个时候判断条件反了过来： 当 left 计数器比 right 计数器大时，将 left 和 right 计数器同时变回 0。 当 left 计数器与 right 计数器相等时，计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。 这样就能涵盖所有情况从而求解出答案。class Solution { public int longestValidParentheses(String s) { int left = 0, right = 0, maxLen = 0; for(int i=0; i&lt;s.length(); i++){ if(s.charAt(i)=='('){ left++; }else{ right++; } if(left==right) maxLen = Math.max(maxLen, left*2); if(left&lt;right){ left = 0; right = 0; } } left = 0; right = 0; for(int i = s.length()-1; i&gt;=0; i--){ if(s.charAt(i)=='('){ left++; }else{ right++; } if(left==right) maxLen = Math.max(maxLen, left*2); if(left&gt;right){ left = 0; right = 0; } } return maxLen; }}复杂度分析 时间复杂度： O(n)，其中 n 为字符串长度。只要正反遍历两边字符串即可。 空间复杂度： O(1)。只需要常数空间存放若干变量。 方法三、栈始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标： 对于遇到的每个 ‘(’ ，将它的下标放入栈中。 对于遇到的每个 ‘)’ ，先弹出栈顶元素表示匹配了当前右括号： 如果栈为空，说明当前的右括号为没有被匹配的右括号，将其下标放入栈中来更新之前提到的「最后一个没有被匹配的右括号的下标」 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，在一开始的时候往栈中放入一个值为 −1 的元素。class Solution { public int longestValidParentheses(String s) { int maxans = 0; Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;(); stack.push(-1); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') { stack.push(i); } else { stack.pop(); if (stack.isEmpty()) { stack.push(i); } else { maxans = Math.max(maxans, i - stack.peek()); } } } return maxans; }}复杂度分析 时间复杂度： O(n)，n 是给定字符串的长度。只需要遍历字符串一次即可。 空间复杂度： O(n)。栈的大小在最坏情况下会达到 n，因此空间复杂度为 O(n) 。 " }, { "title": "31. 下一个排列", "url": "/posts/31-next-permutation/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-07 00:51:00 +0000", "snippet": "问题描述实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须 原地 修改，只允许使用额外常数空间。示例 1：输入：nums = [1,2,3]输出：[1,3,2]示例 2：输入：nums = [3,2,1]输出：[1,2,3]示例 3：输入：nums = [1,1,5]输出：[1,5,1]示例 4：输入：nums = [1]输出：[1]两遍扫描思路：注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地： 需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。 同时**要让这个「较小数」尽量靠右，而「较大数」尽可能小**。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。 以排列 [4,5,2,6,3,1] 为例： 能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。 当完成交换后排列变为 [4,5,3,6,2,1]，此时可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。 具体地，这样描述该算法，对于长度为 n 的排列 a： 首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]&lt;a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。 如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]&lt;a[j]。这样「较大数」即为 a[j]。 交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。 注意 如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列。该方法支持序列中存在重复元素.class Solution { public void nextPermutation(int[] nums) { //寻找第一个顺序对，从倒数第二个元素开始 int i = nums.length-2; while(i&gt;=0 &amp;&amp; nums[i]&gt;nums[i+1]){ i--; } if(i&gt;=0){ int j=nums.length-1; //在右侧找到第一个大于当前nums[i]的值 while(j&gt;i &amp;&amp; nums[i]&gt;nums[j]){ j--; } swap(nums, i, j); } reserve(nums, i+1); } public void swap(int[] nums, int i, int j){ int temp = nums[j]; nums[j] = nums[i]; nums[i] = temp; } public void reserve(int[]nums, int start){ int left = start, right = nums.length-1; while(left&lt;right){ swap(nums, left, right); left++; right--; } }}复杂度分析 时间复杂度：O(N)，其中 N 为给定序列的长度。至多只需要扫描两次序列，以及进行一次反转操作。 空间复杂度：O(1)，只需要常数的空间存放若干变量。 " }, { "title": "30. 串联所有单词的子串", "url": "/posts/30-substring-with-concatenation-of-all-words/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-07 00:50:00 +0000", "snippet": "问题描述" }, { "title": "29. 两数相除", "url": "/posts/29-divide-two-integers/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-07 00:49:00 +0000", "snippet": "问题描述29. 两数相除" }, { "title": "28. 实现 strStr()", "url": "/posts/28-implement-strstr/", "categories": "LeetCode, 字符串", "tags": "数据结构与算法", "date": "2022-07-07 00:48:00 +0000", "snippet": "问题描述实现 strStr() 函数。给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。说明：当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。提示： 1 &lt;= haystack.length, needle.length &lt;= 10^4 haystack 和 needle 仅由小写英文字符组成示例 1：输入：haystack = \"hello\", needle = \"ll\"输出：2示例 2：输入：haystack = \"aaaaa\", needle = \"bba\"输出：-1前言本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等，本文将讲解 Knuth-Morris-Pratt 算法。因为哈希方法可能出现哈希值相等但是字符串不相等的情况，而 strStr 函数要求匹配结果必定正确，因此本文不介绍哈希方法，有兴趣的读者可以自行了解滚动哈希的实现（如 Rabin-Karp 算法）。方法一、暴力匹配让字符串 needle 与字符串 haystack 的所有长度为 m 的子串均匹配一次。为了减少不必要的匹配，每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1。class Solution { public int strStr(String haystack, String needle) { int n = haystack.length(), m = needle.length(); for (int i = 0; i + m &lt;= n; i++) { boolean flag = true; for (int j = 0; j &lt; m; j++) { if (haystack.charAt(i + j) != needle.charAt(j)) { flag = false; break; } } if (flag) { return i; } } return -1; }}复杂度分析 时间复杂度：O(n×m)，其中 n 是字符串 haystack 的长度，m 是字符串 needle 的长度。最坏情况下需要将字符串 needle 与字符串 haystack 的所有长度为 m 的子串均匹配一次。 空间复杂度：O(1)。只需要常数的空间保存若干变量。 方法二、Knuth-Morris-Pratt 算法思路及算法Knuth-Morris-Pratt 算法，简称 KMP 算法，由 Donald Knuth、James H. Morris 和 Vaughan Pratt 三人于 19771977 年联合发表。Knuth-Morris-Pratt 算法的核心为前缀函数，记作 π(i)，其定义如下：对于长度为 m 的字符串 s，其前缀函数 π(i)(0≤i&lt;m) 表示 s 的子串 s[0:i] 的最长的相等的真前缀与真后缀的长度。特别地，如果不存在符合条件的前后缀，那么 π(i)=0。其中真前缀与真后缀的定义为不等于自身的的前缀与后缀。举个例子说明：字符串 aabaaab的前缀函数值依次为 0,1,0,1,2,2,3。 π(0)=0，因为 a 没有真前缀和真后缀，根据规定为 0（可以发现对于任意字符串 π(0)=0 必定成立）； π(1)=1，因为 aa 最长的一对相等的真前后缀为 a，长度为 1； π(2)=0，因为 aab 没有对应真前缀和真后缀，根据规定为 0； π(3)=1，因为 aaba 最长的一对相等的真前后缀为 a，长度为 1； π(4)=2，因为 aabaa 最长的一对相等的真前后缀为 aa，长度为 2； π(5)=2，因为 aabaaa 最长的一对相等的真前后缀为 aa，长度为 2； π(6)=3，因为 aabaaab 最长的一对相等的真前后缀为 aab，长度为 3。 有了前缀函数，我们就可以快速地计算出模式串在主串中的每一次出现。如何求解前缀函数长度为 m 的字符串 s 的所有前缀函数的求解算法的总时间复杂度是严格 O(m) 的，且该求解算法是增量算法，即可以一边读入字符串，一边求解当前读入位的前缀函数。为了叙述方便，接下来将说明几个前缀函数的性质： π(i)≤π(i−1)+1 依据 π(i) 定义得：s[0:π(i)−1]=s[i−π(i)+1:i]。 将两区间的右端点同时左移，可得：s[0:π(i)−2]=s[i−π(i)+1:i−1]。此处是 π(i)−1 对应的等式。 依据 π(i−1) 定义得 π(i−1)≥π(i)−1，即 π(i)≤π(i−1)+1。 如果 s[i]=s[π(i−1)]，那么 π(i)=π(i−1)+1复杂度分析 时间复杂度：O(n+m)，其中 n 是字符串 haystack 的长度，m 是字符串 needle 的长度。至多需要遍历两字符串一次。 空间复杂度：O(m)，其中 m 是字符串 needle 的长度。只需要保存字符串 needle 的前缀函数。 " }, { "title": "27. 移除元素", "url": "/posts/27-remove-element/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-07 00:47:00 +0000", "snippet": "问题描述给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100方法一、双指针由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；如果右指针指向的元素等于val，它不能在输出数组里，此时左指针不动，右指针右移一位。整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。class Solution { public int removeElement(int[] nums, int val) { int n = nums.length; int left = 0; for(int right=0; right&lt;n; right++){ if(nums[right]!=val){ nums[left] = nums[right]; left++; } } return left; }}复杂度分析 时间复杂度：O(n)，其中 n 为序列的长度。只需要遍历该序列至多两次。 空间复杂度：O(1)。只需要常数的空间保存若干变量。 方法二、双指针优化依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。class Solution { public int removeElement(int[] nums, int val) { int left = 0; int right = nums.length-1; while (left &lt;= right) { //必须要有等号 if (nums[left] == val) { nums[left] = nums[right]; right--; } else { left++; } } return left; }}复杂度分析 时间复杂度：O(n)，其中 n 为序列的长度。只需要遍历该序列至多一次。 空间复杂度：O(1)。只需要常数的空间保存若干变量。 " }, { "title": "26. 删除有序数组中的重复项", "url": "/posts/26-remove-duplicates-from-sorted-array/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-07 00:46:00 +0000", "snippet": "问题描述给你一个升序排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。将最终结果插入 nums 的前 k 个位置后返回 k 。不要使用额外的空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。方法一、双指针由于给定的数组 nums 是有序的，因此对于任意 i&lt;j，如果 nums[i]=nums[j]，则对任意 i≤k≤j，必有 nums[i]=nums[k]=nums[j]，即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。如果数组 nums 的长度为 0，则数组不包含任何元素，因此返回 0。当数组 nums 的长度大于 0 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 nums[0] 保持原状即可，从下标 1 开始删除重复元素。定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。假设数组 nums 的长度为 n。将快指针 fast 依次遍历从 1 到 n−1 的每个位置，对于每个位置，如果 nums[fast] 不等于 nums[fast−1]，说明 nums[fast] 和之前的元素都不同，因此将 nums[fast] 的值复制到 nums[slow]，然后将 slow 的值加 1，即指向下一个位置。遍历结束之后，从 nums[0] 到 nums[slow−1] 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 slow，返回 slow 即可。class Solution { public int removeDuplicates(int[] nums) { int n = nums.length; if (n == 0) { return 0; } int fast = 1, slow = 1; while (fast &lt; n) { if (nums[fast] != nums[fast - 1]) { nums[slow] = nums[fast]; ++slow; } ++fast; } return slow; }}复杂度分析 时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。 空间复杂度：O(1)。只需要使用常数的额外空间。 " }, { "title": "25. K 个一组翻转链表", "url": "/posts/25-reverse-nodes-in-k-group/", "categories": "LeetCode, 链表", "tags": "数据结构与算法", "date": "2022-07-07 00:45:00 +0000", "snippet": "问题描述" }, { "title": "24. 两两交换链表中的节点", "url": "/posts/24-swap-nodes-in-pairs/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-07 00:44:00 +0000", "snippet": "问题描述给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100示例 1：输入：head = [1,2,3,4]输出：[2,1,4,3]示例 2：输入：head = []输出：[]示例 3：输入：head = [1]输出：[1]方法一、迭代创建哑结点 dummyHead，令 dummyHead.next = head。令 temp 表示当前到达的节点，初始时 temp = dummyHead。每次需要交换 temp 后面的两个节点。如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。具体而言，交换之前的节点关系是 temp -&gt; node1 -&gt; node2，交换之后的节点关系要变成 temp -&gt; node2 -&gt; node1，因此需要进行如下操作。temp.next = node2node1.next = node2.nextnode2.next = node1完成上述操作之后，节点关系即变成 temp -&gt; node2 -&gt; node1。再令 temp = node1，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。两两交换链表中的节点之后，新的链表的头节点是 dummyHead.next，返回新的链表的头节点即可。class Solution { public ListNode swapPairs(ListNode head) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode temp = dummyHead; while (temp.next != null &amp;&amp; temp.next.next != null) { ListNode node1 = temp.next; ListNode node2 = temp.next.next; temp.next = node2; node1.next = node2.next; node2.next = node1; temp = node1; } return dummyHead.next; }}复杂度分析 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。 空间复杂度：O(1)。 方法二、递归递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode newHead = head.next; head.next = swapPairs(newHead.next); newHead.next = head; return newHead; }}复杂度分析 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。 空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。 " }, { "title": "23. 合并K个升序链表", "url": "/posts/23-merge-k-sorted-lists/", "categories": "LeetCode, 链表", "tags": "数据结构与算法", "date": "2022-07-07 00:43:00 +0000", "snippet": "问题描述" }, { "title": "22. 括号生成", "url": "/posts/22-generate-parentheses/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-07 00:30:00 +0000", "snippet": "问题描述数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且[有效的]括号组合。有效括号组合需满足：左括号必须以正确的顺序闭合。示例 1：输入：n = 3输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]示例 2：输入：n = 1输出：[\"()\"] 提示：1 &lt;= n &lt;= 8相关标签：字符串、动态规划、回溯方法一、回溯法只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，如果左括号数量不大于 n，可以放一个左括号。如果右括号数量小于左括号的数量，可以放一个右括号。class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); backtrack(ans, new StringBuilder(), 0, 0, n); return ans; } public void backtrack(List&lt;String&gt; ans, StringBuilder cur, int open, int close, int max) { if(cur.length()==max*2){ ans.add(cur.toString()); return; } if(open&lt;max){ cur.append('('); backtrack(ans, cur, open+1, close, max); cur.deleteCharAt(cur.length()-1); } //右括号的数量&lt;=左括号！ if(close&lt;open){ //注意此处不是 if(close&lt;max)！！ cur.append(')'); backtrack(ans, cur, open, close+1, max); cur.deleteCharAt(cur.length()-1); } }}方法二、暴力法(不推荐)生成所有序列，然后检查序列是否有效。1）为了生成所有序列，可以使用递归。长度为 n 的序列就是在长度为 n-1 的序列前加一个 ‘(‘ 或 ‘)’。2）为了检查序列是否有效，遍历这个序列，并使用一个变量 balance 表示左括号的数量减去右括号的数量。**如果在遍历过程中 balance 的值小于零，或者结束时 balance 的值不为零，那么该序列就是无效的，否则它是有效的。**class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); generateAll(new char[n*2], 0, ans); return ans; } public void generateAll(char[] current, int pos, List&lt;String&gt; result){ if(pos==current.length){ if(valid(current)) result.add(new String(current)); return; } current[pos]='('; generateAll(current, pos+1, result); current[pos]=')'; generateAll(current, pos+1, result); } public boolean valid(char[] current){ int balance = 0; for(char c: current){ if(c=='('){ balance++; }else{ balance--; } if(balance&lt;0) return false; } return balance==0; }}复杂度分析 时间复杂度：O(2^{2n}n)，对于 2^{2n}个序列中的每一个，用于建立和验证该序列的复杂度为 O(n)。 空间复杂度：O(n)，除了答案数组之外，所需要的空间取决于递归栈的深度，每一层递归函数需要 O(1) 的空间，最多递归 2n 层，因此空间复杂度为 O(n)。 方法三、按括号序列的长度递归任何一个括号序列都一定是由 ( 开头，并且第一个 ( 一定有一个唯一与之对应的 )。这样一来，每一个括号序列可以用 (a)b 来表示，其中 a 与 b 分别是一个合法的括号序列（可以为空）。那么，要生成所有长度为 2 * n 的括号序列，定义一个函数 generate(n) 来返回所有可能的括号序列。那么在函数 generate(n) 的过程中： 需要枚举与第一个 ( 对应的 ) 的位置 2 * i + 1； 递归调用 generate(i) 即可计算 a 的所有可能性； 递归调用 generate(n - i - 1) 即可计算 b 的所有可能性； 遍历 a 与 b 的所有可能性并拼接，即可得到所有长度为 2 * n 的括号序列。为了节省计算时间，在每次 generate(i) 函数返回之前，把返回值存储起来，下次再调用 generate(i) 时可以直接返回，不需要再递归计算。class Solution { ArrayList[] cache = new ArrayList[100]; public List&lt;String&gt; generate(int n) { if (cache[n] != null) { return cache[n]; } ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;(); if (n == 0) { ans.add(\"\"); } else { for (int c = 0; c &lt; n; ++c) { for (String left: generate(c)) { for (String right: generate(n - 1 - c)) { ans.add(\"(\" + left + \")\" + right); } } } } cache[n] = ans; return ans; } public List&lt;String&gt; generateParenthesis(int n) { return generate(n); }}时空复杂度均为 O(4^n/sqrt(n))。" }, { "title": "21. 合并两个有序链表", "url": "/posts/21-merge-two-sorted-lists/", "categories": "LeetCode, 链表", "tags": "数据结构与算法", "date": "2022-07-06 23:41:00 +0000", "snippet": "问题描述将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。提示：l1 和 l2 均按【非递减顺序】排列，-100 &lt;= Node.val &lt;= 100，两个链表的节点数目范围是 [0, 50]。示例 1：输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]示例 2：输入：l1 = [], l2 = []输出：[]示例 3：输入：l1 = [], l2 = [0]输出：[0]方法一、迭代实现一class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode head = new ListNode(); ListNode curr = head; while(l1!=null &amp;&amp; l2!=null){ if(l1.val &lt;=l2.val){ curr.next = l1; l1 = l1.next; }else{ curr.next = l2; l2 = l2.next; } curr = curr.next; } if(l1!=null) curr.next = l1; if(l2!=null) curr.next = l2; return head.next; }}复杂度分析 时间复杂度：O(n + m)。 空间复杂度：O(1)。 实现二class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode l = new ListNode(-1),p=l; while(l1!=null || l2!=null){ if(l1==null) { p.next = l2; break; } if(l2==null){ p.next = l1; break; } if(l1.val&lt;=l2.val){ p.next = l1; l1 = l1.next; }else{ p.next = l2; l2 = l2.next; } p = p.next; } return l.next; }}方法二、递归class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }}复杂度分析 时间复杂度：O(n + m)。 空间复杂度：O(n + m)。 " }, { "title": "20. 有效的括号", "url": "/posts/20-valid-parentheses/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-06 10:40:00 +0000", "snippet": "问题描述给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：- 左括号必须用相同类型的右括号闭合。- 左括号必须以正确的顺序闭合。示例 1：输入：s = \"()\"输出：true示例 2：输入：s = \"()[]{}\"输出：true示例 3：输入：s = \"(]\"输出：false示例 4：输入：s = \"([)]\"输出：false示例 5：输入：s = \"{[]}\"输出：true相关标签：字符串、栈方法stack 没有 top 函数！请使用 peek 函数。实现一class Solution { public boolean isValid(String s) { int n = s.length(); if(n==0) return true; if(n%2==1) return false; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); map.put(')', '('); map.put(']', '['); map.put('}', '{'); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for(Character c : s.toCharArray()){ if(c=='(' || c=='{' || c=='['){ stack.push(c); }else{ if(stack.isEmpty() || stack.pop()!=map.get(c)) return false; } } return stack.isEmpty(); }}实现二class Solution { public boolean isValid(String s) { int n = s.length(); if(n==0) return true; if(n%2==1) return false; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); map.put(')','('); map.put(']','['); map.put('}','{'); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for(int i=0; i&lt;n; i++){ char c = s.charAt(i); if(c=='(' || c=='[' || c=='{'){ stack.push(c); }else if(stack.isEmpty() || stack.peek()!=map.get(c)){ return false; }else{ stack.pop(); } } //不能直接返回true return stack.isEmpty(); }}实现三class Solution { public boolean isValid(String s) { int n = s.length(); if(n==0) return true; if(n%2==1) return false; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); map.put(')','('); map.put(']','['); map.put('}','{'); for(int i=0; i&lt;n; i++){ char c = s.charAt(i); if(c=='(' || c=='{' || c=='['){ stack.push(c); }else{ if(!stack.isEmpty() &amp;&amp; stack.peek()==map.get(c)){ stack.pop(); }else{ return false; } } } return stack.isEmpty(); }}" }, { "title": "19. 删除链表的倒数第 N 个结点", "url": "/posts/19-remove-nth-node-from-end-of-list/", "categories": "LeetCode, 链表", "tags": "数据结构与算法", "date": "2022-07-06 10:39:00 +0000", "snippet": "问题描述给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？示例 1：输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]示例 2：输入：head = [1], n = 1输出：[]示例 3：输入：head = [1,2], n = 1输出：[1]方法一、计算链表长度首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1 个节点时，它就是需要删除的节点。为了与题目中的 n 保持一致，节点的编号从 1 开始，头节点为编号 1 的节点。为了方便删除操作，从哑节点开始遍历 L−n+1 个节点。当遍历到第 L−n+1 个节点时，它的下一个节点就是需要删除的节点，这样只需要修改一次指针，就能完成删除操作。class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dump = new ListNode(); dump.next = head; int len = getLength(head); if(n&gt;len) return head; ListNode cur = dump; for(int i=1; i&lt;len-n+1;i++){ cur = cur.next; } cur.next = cur.next.next; return dump.next; } public int getLength(ListNode head){ int len = 0; while(head!=null){ len++; head = head.next; } return len; }}复杂度分析 时间复杂度：O(L)，其中 L 是链表的长度。 空间复杂度：O(1)。 方法二、双指针(ok)由于需要找到倒数第 n 个节点，因此可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。具体地，初始时 first 和 second 均指向头节点。首先使用 first 对链表进行遍历，遍历的次数为 n。此时，first 和 second 之间间隔了 n−1 个节点，即 first 比 second 超前了 n 个节点。在这之后，同时使用 first 和 second 对链表进行遍历。当 first 遍历到链表的末尾（即 first 为空指针）时，second 恰好指向倒数第 n 个节点。如果能够得到的是倒数第 n 个节点的【前驱节点】而不是倒数第 n 个节点的话，删除操作会更加方便。因此可以考虑在初始时将 second 指向【哑节点】，其余的操作步骤不变。这样一来，当 first 遍历到链表的末尾时，second 的下一个节点就是需要删除的节点。class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0, head); ListNode first = head; ListNode second = dummy; int i=0; for(; i&lt;n &amp;&amp; first!=null; i++){ first = first.next; } if(i&lt;n){ return head; } while(first!=null){ first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; }}复杂度分析 时间复杂度：O(L)，其中 L 是链表的长度。 空间复杂度：O(1)。 方法三、栈class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0, head); Deque&lt;ListNode&gt; stack = new LinkedList&lt;ListNode&gt;(); ListNode cur = dummy; while (cur != null) { stack.push(cur); cur = cur.next; } for (int i = 0; i &lt; n; ++i) { stack.pop(); } ListNode prev = stack.peek(); prev.next = prev.next.next; ListNode ans = dummy.next; return ans; }}" }, { "title": "18. 四数之和", "url": "/posts/18-4sum/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-06 10:38:00 +0000", "snippet": "问题描述给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target可以按任意顺序返回答案。提示： 1 &lt;= nums.length &lt;= 200 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109示例 1：输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]示例 2：输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]]方法一、排序 + 双指针本题与「15. 三数之和」相似，解法也相似。使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。假设两重循环枚举到的前两个数分别位于下标 i 和 j，其中 i&lt;j。初始时，左右指针分别指向下标 j+1 和下标 n−1。每次计算四个数的和，并进行如下操作： 如果和等于 target，则将枚举到的四个数加到答案中，然后将左指针右移直到遇到不同的数，将右指针左移直到遇到不同的数； 如果和小于 target，则将左指针右移一位； 如果和大于 target，则将右指针左移一位。 使用双指针枚举剩下的两个数的时间复杂度是 O(n)，因此总时间复杂度是 O(n^3)，低于O(n^4)。 具体实现时，还可以进行一些剪枝操作： 在确定第一个数之后，如果 nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target，说明此时剩下的三个数无论取什么值，四数之和一定大于 target，因此退出第一重循环； 在确定第一个数之后，如果 nums[i]+nums[n−3]+nums[n−2]+nums[n−1]&lt;target，说明此时剩下的三个数无论取什么值，四数之和一定小于 target，因此第一重循环直接进入下一轮，枚举 nums[i+1]； 在确定前两个数之后，如果 nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target，说明此时剩下的两个数无论取什么值，四数之和一定大于 target，因此退出第二重循环； 在确定前两个数之后，如果 nums[i]+nums[j]+nums[n−2]+nums[n−1]&lt;target，说明此时剩下的两个数无论取什么值，四数之和一定小于 target，因此第二重循环直接进入下一轮，枚举 nums[j+1]。 class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {List&lt;List&lt;Integer&gt;&gt; quadruplets = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (nums == null || nums.length &lt; 4) { return quadruplets; } Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 3; i++) { //第一个元素去重 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) { //此后所有4个元素之和都大于target break; } if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) { continue; } for (int j = i + 1; j &lt; length - 2; j++) { //第二个元素去重 if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) { continue; } if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) { break; } if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) { continue; } int left = j + 1, right = length - 1; while (left &lt; right) { int sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum == target) { quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left++; } left++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } right--; } else if (sum &lt; target) { left++; } else { right--; } } } } return quadruplets; }}复杂度分析 时间复杂度：O(n^3)，其中 n 是数组的长度。排序的时间复杂度是 O(nlogn)，枚举四元组的时间复杂度是 O(n^3)，因此总时间复杂度为 O(n^3+nlog n)=O(n^3)。 空间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组 nums，实际情况中不一定允许，因此也可以看成使用了一个额外的数组存储了数组 nums 的副本并排序，空间复杂度为 O(n)。 " }, { "title": "17. 电话号码的字母组合", "url": "/posts/17-letter-combinations-of-a-phone-number/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-06 10:37:00 +0000", "snippet": "问题描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。digits[i] 是范围 ['2', '9'] 的一个数字。示例 1：输入：digits = \"23\"输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]示例 2：输入：digits = \"\"输出：[]示例 3：输入：digits = \"2\"输出：[\"a\",\"b\",\"c\"]方法一、回溯首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。class Solution { public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if(digits.length() == 0 || digits==null) return ans; Map&lt;Character, String&gt; map = new HashMap&lt;&gt;(); map.put('2',\"abc\"); map.put('3',\"def\"); map.put('4',\"ghi\"); map.put('5',\"jkl\"); map.put('6',\"mno\"); map.put('7',\"pqrs\"); map.put('8',\"tuv\"); map.put('9',\"wxyz\"); dfs(map, ans, digits, new StringBuilder(), 0); return ans; } public void dfs(Map&lt;Character, String&gt; map, List&lt;String&gt; ans, String digits, StringBuilder sb, int i){ if(i&gt;=digits.length()){ ans.add(sb.toString()); //或 new String(sb) return; } char c = digits.charAt(i); String s = map.get(c); for(int k=0;k&lt;s.length();k++){ sb.append(s.charAt(k)); dfs(map, ans, digits, sb, i+1); sb.deleteCharAt(i); //! deleteCharAt } }}复杂度分析 时间复杂度：O(3^m × 4^n)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。当输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字时，不同的字母组合一共有 3^m × 4^n 种，需要遍历每一种字母组合。 空间复杂度：O(m+n)，其中 m 是输入中对应 3 个字母的数字个数，n 是输入中对应 4 个字母的数字个数，m+n 是输入数字的总个数。除了返回值以外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 m+n。 " }, { "title": "16. 最接近的三数之和", "url": "/posts/16-3sum-closest/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-06 10:36:00 +0000", "snippet": "问题描述给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。示例 1：输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。示例 2：输入：nums = [0,0,0], target = 1输出：0 提示： 3 &lt;= nums.length &lt;= 1000 -1000 &lt;= nums[i] &lt;= 1000 -104 &lt;= target &lt;= 104方法一、排序 + 双指针本题与 15. 三数之和 非常类似，可以使用「双指针」的方法来解决。class Solution { public int threeSumClosest(int[] nums, int target) { int n = nums.length; if(n&lt;3) return 0; Arrays.sort(nums); int res = 100000; for(int i=0; i&lt;n-2; i++){ //!!移动到下一个不相等的元素 if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; int low = i+1; int high = n-1; while(low&lt;high){ int sum = nums[i]+nums[low]+nums[high]; if(sum==target){ return target; } if(Math.abs(sum-target)&lt;Math.abs(res-target)){ res = sum; } //!!移动到下一个不相等的元素 if(sum&gt;target){ while(low&lt;high &amp;&amp; nums[high]==nums[high-1]){ high--; } high--; }else{ while(low&lt;high &amp;&amp; nums[low]==nums[low+1]){ low++; } low++; } } } return res; }}复杂度分析 时间复杂度：O(N^2)，其中 N 是数组 nums 的长度。首先需要 O(NlogN) 的时间对数组进行排序，随后在枚举的过程中，使用一重循环 O(N) 枚举 a，双指针 O(N) 枚举 b 和 c，故一共是 O(N^2)。 空间复杂度：O(logN)。排序需要使用 O(logN) 的空间。然而修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，此时空间复杂度为 O(N)。 " }, { "title": "15. 三数之和", "url": "/posts/15-3sum/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-06 10:35:00 +0000", "snippet": "问题描述给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。示例 1：输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]示例 2：输入：nums = []输出：[]示例 3：输入：nums = [0]输出：[]方法一、排序 + 双指针1）简单地使用三重循环枚举所有的三元组，不能保证「不重复」。2）「不重复」的本质是什么？保持三重循环的大框架不变，只需要保证： 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素； 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。 也就是说，枚举的三元组 (a, b, c) 满足 a≤b≤c，保证了只有 (a, b, c) 这个顺序会被枚举到，而 (b, a, c)、(c, b, a) 等等这些不会，这样就减少了重复。要实现这一点，可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。3）同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。[0, 1, 2, 2, 2, 3] ^ ^ ^使用三重循环枚举到的第一个三元组为 (0, 1, 2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)，产生了重复。因此需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 (0, 1, 3)。方法的时间复杂度仍然为 O(N^3)。4）优化可以发现，如果固定了前两重循环枚举到的元素 a 和 b，那么只有唯一的 c 满足 a+b+c=0。当第二重循环往后枚举一个元素 b’时，由于 b’&gt;b，那么满足 a+b’+c’=0 的 c’ 一定有 c’&lt;c，即 c’ 在数组中一定出现在 c 的左侧。也就是说，可以从小到大枚举 b，同时从大到小枚举 c，即第二重循环和第三重循环实际上是并列的关系。使用「双指针」实现上述过程。实现一class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; arr = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(nums.length &lt; 3){ return arr; } //排序 Arrays.sort(nums); if(nums[0] &gt; 0){ return arr; } for(int i = 0; i &lt; nums.length-2; i++){ int target = 0 - nums[i]; //去重 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]){ continue; } int l = i+1; int r = nums.length - 1; while(l &lt; r){ if(nums[l] + nums[r] == target){ //存入符合要求的值 arr.add(new ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[l], nums[r]))); //这里需要注意顺序 while(l &lt; r &amp;&amp; nums[l] == nums[l+1]) l++; while(l &lt; r &amp;&amp; nums[r] == nums[r-1]) r--; l++; r--; } else if(nums[l] + nums[r] &gt; target){ r--; } else{ l++; } } } return arr; }}实现二class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { int n = nums.length; //排序！ Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int f1 = 0;f1&lt;n-2; f1++){ if(f1&gt;0 &amp;&amp; nums[f1]==nums[f1-1]) continue; int f3 = n-1; int target = -nums[f1]; for(int f2=f1+1; f2&lt;n-1; f2++){ if(f2&gt;f1+1 &amp;&amp; nums[f2]==nums[f2-1]) continue; while(f2&lt;f3 &amp;&amp; nums[f2]+nums[f3]&gt;target){ f3--; } if(f2==f3) break; if(nums[f2]+nums[f3]==target){ List&lt;Integer&gt; t = new ArrayList&lt;&gt;(); t.add(nums[f1]); t.add(nums[f2]); t.add(nums[f3]); ans.add(t); } } } return ans; }}复杂度分析 时间复杂度：O(N^2)，其中 N 是数组 - nums 的长度。 空间复杂度：O(logN)。忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。 " }, { "title": "14. 最长公共前缀", "url": "/posts/14-longest-common-prefix/", "categories": "LeetCode, 字符串", "tags": "数据结构与算法", "date": "2022-07-06 10:34:00 +0000", "snippet": "问题描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ““。提示： 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] 仅由小写英文字母组成示例 1：输入：strs = [\"flower\",\"flow\",\"flight\"]输出：\"fl\"示例 2：输入：strs = [\"dog\",\"racecar\",\"car\"]输出：\"\"解释：输入不存在公共前缀。方法一、横向扫描基于该结论，可以得到一种查找字符串数组中的最长公共前缀的简单方法。依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } String prefix = strs[0]; int count = strs.length; for (int i = 1; i &lt; count; i++) { prefix = longestCommonPrefix(prefix, strs[i]); if (prefix.length() == 0) { break; } } return prefix; } public String longestCommonPrefix(String str1, String str2) { int length = Math.min(str1.length(), str2.length()); int index = 0; while (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) { index++; } return str1.substring(0, index); }}复杂度分析 时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。 空间复杂度：O(1)。使用的额外空间复杂度为常数。 方法二、纵向扫描方法一是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } int length = strs[0].length(); int count = strs.length; for (int i = 0; i &lt; length; i++) { char c = strs[0].charAt(i); for (int j = 1; j &lt; count; j++) { if (i == strs[j].length() || strs[j].charAt(i) != c) { return strs[0].substring(0, i); } } } return strs[0]; }}复杂度分析 时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。 空间复杂度：O(1)。使用的额外空间复杂度为常数。 方法三、分治class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } else { return longestCommonPrefix(strs, 0, strs.length - 1); } } public String longestCommonPrefix(String[] strs, int start, int end) { if (start == end) { return strs[start]; } else { int mid = (end - start) / 2 + start; String lcpLeft = longestCommonPrefix(strs, start, mid); String lcpRight = longestCommonPrefix(strs, mid + 1, end); return commonPrefix(lcpLeft, lcpRight); } } public String commonPrefix(String lcpLeft, String lcpRight) { int minLength = Math.min(lcpLeft.length(), lcpRight.length()); for (int i = 0; i &lt; minLength; i++) { if (lcpLeft.charAt(i) != lcpRight.charAt(i)) { return lcpLeft.substring(0, i); } } return lcpLeft.substring(0, minLength); }}复杂度分析 时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。时间复杂度的递推式是 T(n)=2⋅T(n/2)+O(m)，通过计算可得 T(n)=O(mn)。 空间复杂度：O(mlogn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。空间复杂度主要取决于递归调用的层数，层数最大为 logn，每层需要 m 的空间存储返回结果。 方法四、二分查找显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用 minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值 mid，判断每个字符串的长度为 mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于 mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } int minLength = Integer.MAX_VALUE; for (String str : strs) { minLength = Math.min(minLength, str.length()); } int low = 0, high = minLength; while (low &lt; high) { int mid = (high - low + 1) / 2 + low; if (isCommonPrefix(strs, mid)) { low = mid; } else { high = mid - 1; } } return strs[0].substring(0, low); } public boolean isCommonPrefix(String[] strs, int length) { String str0 = strs[0].substring(0, length); int count = strs.length; for (int i = 1; i &lt; count; i++) { String str = strs[i]; for (int j = 0; j &lt; length; j++) { if (str0.charAt(j) != str.charAt(j)) { return false; } } } return true; }}复杂度分析 时间复杂度：O(mnlogm)，其中 m 是字符串数组中的字符串的最小长度，n 是字符串的数量。二分查找的迭代执行次数是 O(logm)，每次迭代最多需要比较 mn 个字符，因此总时间复杂度是 O(mnlogm)。 空间复杂度：O(1)。使用的额外空间复杂度为常数。 " }, { "title": "13. 罗马数字转整数", "url": "/posts/13-luo-ma-shu-zi-zhuan-zheng-shu/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-06 10:33:00 +0000", "snippet": "问题描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。  C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。示例 1:输入: s = \"III\"输出: 3示例 2:输入: s = \"IV\"输出: 4示例 3:输入: s = \"IX\"输出: 9示例 4:输入: s = \"LVIII\"输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: s = \"MCMXCIV\"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.方法、模拟通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。例如 XIV 可视作 X−I+V=10−1+5=14。class Solution { Map&lt;Character, Integer&gt; symbolValues = new HashMap&lt;Character, Integer&gt;() ; public int romanToInt(String s) { int res = 0, n = s.length(); for(int i=0; i&lt;n; i++){ int value = symbolValues.get(s.charAt(i)); if(i&lt;n-1 &amp;&amp; value&lt; symbolValues.get(s.charAt(i+1))){ res -= value; }else{ res += value; } } return res; }}复杂度分析 时间复杂度：O(n)，其中 n 是字符串 s 的长度。 空间复杂度：O(1)。 " }, { "title": "12. 整数转罗马数字", "url": "/posts/12-integer-to-roman/", "categories": "LeetCode, XXX", "tags": "数据结构与算法", "date": "2022-07-06 10:32:00 +0000", "snippet": "问题描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。  C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给你一个整数(1 &lt;= num &lt;= 3999)，将其转为罗马数字。示例 1:输入: num = 3输出: \"III\"示例 2:输入: num = 4输出: \"IV\"示例 3:输入: num = 9输出: \"IX\"示例 4:输入: num = 58输出: \"LVIII\"解释: L = 50, V = 5, III = 3.示例 5:输入: num = 1994输出: \"MCMXCIV\"解释: M = 1000, CM = 900, XC = 90, IV = 4.前言罗马数字符号：罗马数字由 7 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 6 个复合符号。这给总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成），如下图所示。罗马数字的唯一表示法：从一个例子入手。考虑 140 的罗马数字表示，下面哪一个是正确的？用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为C=100。接下来，对于剩余的数字 40，最大可以选择的符号值为 XL=40。因此，140 的对应的罗马数字为 C+XL=CXL。方法一、模拟根据罗马数字的唯一表示法，为了表示一个给定的整数 num，寻找不超过 num 的最大符号值，将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为 num 的罗马数字表示。编程时，可以建立一个数值-符号对的列表 valueSymbols，按数值从大到小排列。遍历 valueSymbols 中的每个数值-符号对，若当前数值 value 不超过 num，则从 num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。class Solution { public String intToRoman(int num) { int[] values = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; String[] strs = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}; StringBuffer sb = new StringBuffer(); for(int i=0; i&lt;values.length; i++){ int v = values[i]; String s = strs[i]; while(num&gt;=v){ sb.append(s); num -= v; } if(num==0){ break; } } return sb.toString(); }}复杂度分析 时间复杂度：O(1)。由于 valueSymbols 长度是固定的，且这 13 字符中的每个字符的出现次数均不会超过 3，因此循环次数有一个确定的上限。对于本题给出的数据范围，循环次数不会超过 15 次。 空间复杂度：O(1)。 方法二、硬编码数字回顾前言中列出的这 13 个符号，可以发现： 千位数字只能由 M 表示； 百位数字只能由 C，CD，D 和 CM 表示； 十位数字只能由 X，XL，L 和 XC 表示； 个位数字只能由 I，IV，V 和 IX 表示。这恰好把这 13 个符号分为四组，且组与组之间没有公共的符号。因此，整数 num 的十进制表示中的每一个数字都是可以单独处理的。进一步地，可以计算出每个数字在每个位上的表示形式，整理成一张硬编码表。如下图所示，其中 0 对应的是空字符串。利用模运算和除法运算，可以得到 num 每个位上的数字：thousands_digit = num / 1000hundreds_digit = (num % 1000) / 100tens_digit = (num % 100) / 10ones_digit = num % 10最后，根据 num 每个位上的数字，在硬编码表中查找对应的罗马字符，并将结果拼接在一起，即为 num 对应的罗马数字。class Solution { String[] thousands = {\"\", \"M\", \"MM\", \"MMM\"}; String[] hundreds = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}; String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}; String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}; public String intToRoman(int num) { StringBuffer roman = new StringBuffer(); roman.append(thousands[num / 1000]); roman.append(hundreds[num % 1000 / 100]); roman.append(tens[num % 100 / 10]); roman.append(ones[num % 10]); return roman.toString(); }}复杂度分析 时间复杂度：O(1)。计算量与输入数字的大小无关。 空间复杂度：O(1)。 " }, { "title": "11. 盛水最多的容器", "url": "/posts/11-sheng-zui-duo-shui-de-rong-qi/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-06 10:31:00 +0000", "snippet": "问题描述给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例： 输入：[1,8,6,2,5,4,8,3,7]输出：49 Related Topics 数组 双指针 方法一、双指针1）使用「双指针」，初始时，左右指针分别指向数组的左右两端，计算当前容量。[1, 8, 6, 2, 5, 4, 8, 3, 7] ^ ^2）移动指针。移动原则是[移动对应数字较小的那个指针]。因为，容纳的水量=两个指针指向的数字中较小值∗指针之间的距离，而无论是移动左指针还是移动右指针，指针之间的距离是不变的。3）重新计算当前容量，更新容量最大值。重复步骤2直到两个指针相遇。class Solution { public int maxArea(int[] height) { int l=0, r=height.length-1; int ans=0; while(l&lt;r){ int content = (r-l)*Math.min(height[l], height[r]); ans = Math.max(ans, content); if(height[l]&lt;height[r]){ l++; }else{ r--; } } return ans; }}证明：为什么双指针的做法是正确的？双指针代表的是【可以作为容器边界的所有位置的范围】。在一开始，双指针指向数组的左右边界，表示【数组中所有的位置都可以作为容器的边界】，因为还没有进行过任何尝试。在这之后，每次将【对应的数字较小的那个指针】往【另一个指针】的方向移动一个位置，就表示认为【这个指针不可能再作为容器的边界了】。为什么对应的数字较小的那个指针不可能再作为容器的边界了？考虑第一步，假设当前左指针和右指针指向的数分别为 x 和 y，不失一般性，假设 x≤y。同时，两个指针之间的距离为 t。那么，它们组成的容器的容量为：min(x,y)∗t=x∗t。可以断定，如果保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 x∗t 了。注意这里右指针只能向左移动，因为考虑的是第一步，也就是指针还指向数组的左右边界的时候。也就是说，这个左指针对应的数不会作为容器的边界了，那么就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。" }, { "title": "10. 正则表达式匹配", "url": "/posts/10-zheng-ze-biao-da-shi-pi-pei/", "categories": "LeetCode, 字符串", "tags": "数据结构与算法", "date": "2022-07-06 10:30:00 +0000", "snippet": "问题描述给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。输入:s = \"aa\"p = \"a\"输出: false解释: \"a\" 无法匹配 \"aa\" 整个字符串。输入:s = \"aa\"p = \"a*\"输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素,在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。输入:s = \"ab\"p = \".*\"输出: true解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。输入:s = \"aab\"p = \"c*a*b\"输出: true解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。输入:s = \"mississippi\"p = \"mis*is*p*.\"输出: false Related Topics 字符串 动态规划 回溯算法方法一、动态规划题目中的匹配是一个「逐步匹配」的过程：每次从字符串 p 中取出一个字符或者「字符 + 星号」的组合，并在 s 中进行匹配。对于 p 中一个字符而言，它只能在 s 中匹配一个字符，匹配的方法具有唯一性；而对于 p 中「字符 + 星号」的组合而言，它可以在 s 中匹配任意自然数个字符，并不具有唯一性。因此可以考虑使用动态规划，对匹配的方案进行枚举。用 f[i][j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配。在进行状态转移时，考虑 p 的第 j 个字符的匹配情况：细节：动态规划的边界条件为 f[0][0]=true，即两个空字符串是可以匹配的。最终的答案即为 f[m][n]，其中 m 和 n 分别是字符串 s 和 p 的长度。来源：https://leetcode-cn.com/u/newhar/以一个例子详解动态规划转移方程：S = abbbbcP = ab*d*c1. 当 i, j 指向的字符均为字母（或 '.' 可以看成一个特殊的字母）时， 只需判断对应位置的字符即可， 若相等，只需判断 i,j 之前的字符串是否匹配即可，转化为子问题 f[i-1][j-1]. 若不等，则当前的 i,j 肯定不能匹配，为 false. f[i-1][j-1] i | | S [a b b b b][c] P [a b * d *][c] | j 2. 如果当前 j 指向的字符为 '*'，则不妨把类似 'a*', 'b*' 等的当成整体看待。 看下面的例子 i | S a b [b] b b c P a [b *] d * c | j 注意到当 'b*' 匹配完 'b' 之后，它仍然可以继续发挥作用。 因此可以只把 i 前移一位，而不丢弃 'b*', 转化为子问题 f[i-1][j]: i | &lt;-- S a [b] b b b c P a [b *] d * c | j 另外，也可以选择让 'b*' 不再进行匹配，把 'b*' 丢弃。 转化为子问题 f[i][j-2]: i | S a b [b] b b c P [a] b * d * c | j &lt;--3. 冗余的状态转移不会影响答案， 因为当 j 指向 'b*' 中的 'b' 时, 这个状态对于答案是没有用的, 原因参见评论区 稳中求胜 的解释, 当 j 指向 '*' 时, dp[i][j]只与dp[i][j-2]有关, 跳过了 dp[i][j-1].代码class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); //该数组默认的元素是false //用 f[i][j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配 boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; //i 为 0，j 不为 0。需要判断，可能存在匹配。因为 * 可以消掉一个字符。 //i 不为 0，j 为 0。则一定不匹配。因此从 j=1 开始判断。 //i=1 表示 s 的第一个字符，其在字符串中的索引对应着0！ for(int i=0; i&lt;=m; i++){ for(int j=1; j&lt;=n; j++){ if(p.charAt(j - 1)=='*'){ f[i][j] = f[i][j-2]; if(matches(s, p, i, j-1)){ f[i][j] = f[i][j] || f[i-1][j]; } }else{ if(matches(s, p, i, j)){ f[i][j] = f[i-1][j-1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { //双for循环i从0开始而j从1开始，所以此处只需要判断i的值是否合法。 if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); }}复杂度分析 时间复杂度：O(mn)，其中 m 和 n 分别是字符串 s 和 p 的长度。需要计算出所有的状态，并且每个状态在进行转移时的时间复杂度为 O(1)。 空间复杂度：O(mn)，即为存储所有状态使用的空间。 " }, { "title": "9. 回文数", "url": "/posts/9-palindrome-number/", "categories": "LeetCode, 数学", "tags": "数据结构与算法", "date": "2022-07-06 09:30:00 +0000", "snippet": "问题描述给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。-2^31 &lt;= x &lt;= 2^31 - 1示例 1：输入：x = 121输出：true示例 2：输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3：输入：x = 10输出：false解释：从右向左读, 为 01 。因此它不是一个回文数。进阶：你能不将整数转为字符串来解决这个问题吗？方法一、反转一半数字思路 映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。 第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 int.MAX，将遇到整数溢出问题。 按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。例如，输入 1221，可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，得知数字 1221 是回文。 算法首先，应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以可以对所有大于 0 且个位是 0 的数字返回 false。现在，来考虑如何反转后半部分的数字。如何知道反转数字的位数已经达到原始数字位数的一半？由于整个过程不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着已经处理了一半位数的数字了。class Solution { public boolean isPalindrome(int x) { if(x&lt;0 || (x&gt;0 &amp;&amp; x%10==0)) return false; int revertedNumber = 0; while(x &gt; revertedNumber){ revertedNumber = revertedNumber*10 + x%10; x /= 10; } return x==revertedNumber || x==revertedNumber/10; }}复杂度分析 时间复杂度：O(logn)，对于每次迭代，会将输入除以 10，因此时间复杂度为 O(logn)。 空间复杂度：O(1)。只需要常数空间存放若干变量。方法二、反转所有数字 如果反转后的数字大于 int.MAX，将遇到整数溢出问题。class Solution { public boolean isPalindrome(int x) { if(x&lt;0) return false; int rev = 0, old_v = x; while(x != 0){ int digit = x % 10; x = x / 10; rev = rev*10+digit; } return rev==old_v; }}方法三、字符串-双指针class Solution { public boolean isPalindrome(int x) { if(x&lt;0) return false; String s = String.valueOf(x); int l=0, r=s.length()-1; while(l&lt;r){ if(s.charAt(l) != s.charAt(r)){ return false; } l++; r--; } return true; }}" }, { "title": "8. 字符串转换整数", "url": "/posts/8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi/", "categories": "LeetCode, 字符串", "tags": "数据结构与算法", "date": "2022-07-06 08:40:00 +0000", "snippet": "问题描述请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成。函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，\"123\" -&gt; 123， \"0032\" -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。6. 具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。 返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ' ' 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。示例 1：输入：s = \"42\"输出：42解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。第 1 步：\"42\"（当前没有读入字符，因为没有前导空格） ^第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'） ^第 3 步：\"42\"（读入 \"42\"） ^解析得到整数 42 。由于 \"42\" 在范围 [-231, 231 - 1] 内，最终结果为 42 。示例 2：输入：s = \" -42\"输出：-42解释：第 1 步：\" -42\"（读入前导空格，但忽视掉） ^第 2 步：\" -42\"（读入 '-' 字符，所以结果应该是负数） ^第 3 步：\" -42\"（读入 \"42\"） ^解析得到整数 -42 。由于 \"-42\" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。示例 3：输入：s = \"4193 with words\"输出：4193解释：第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格） ^第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'） ^第 3 步：\"4193 with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止） ^解析得到整数 4193 。由于 \"4193\" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。方法一、模拟特殊用例： \"+-12\" \"00000-42a1234\" \"words and 987\" \" -42\" \" \" \"2147483648\" \"-2147483647\"class Solution { public int myAtoi(String s) { int res = 0, flag = 1; boolean appearNum = false; for(int i=0; i&lt;s.length(); i++){ char c = s.charAt(i); //去除前导空格 while(!appearNum &amp;&amp; i+1&lt;s.length() &amp;&amp; c==' '){ i++; c = s.charAt(i); } //去除符号，符号可能存在多个（返回0） if(!appearNum &amp;&amp; (c=='+' || c=='-')){ if(i+1 &lt; s.length() &amp;&amp; !Character.isDigit(s.charAt(i+1))){ //\"+-12\" return res; } if(c=='-'){ flag *= -1; } if(i+1 &lt; s.length()){ i++; //为了后面判断出现非数字字符，可直接返回。排除了\"+/-\" c = s.charAt(i); } } //去除前导空格以及符号后，若出现非数字，直接返回 if(!Character.isDigit(c)){ return res; } if(Character.isDigit(c)){ appearNum = true; int digit = c-'0'; //判断边界条件!! if(res &lt; (Integer.MIN_VALUE+digit)/10){ return Integer.MIN_VALUE; }else if(res &gt; (Integer.MAX_VALUE-digit)/10){ return Integer.MAX_VALUE; } res = res*10+flag * digit; } } return res; }}方法二、自动机思路字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。因此，为了有条理地分析每个输入字符的处理方法，可以使用自动机这个概念：程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s'。这样，只需要建立一个覆盖所有情况的从 s 与 c 映射到 s' 的表格即可解决题目中的问题。算法本题可以建立如下图所示的自动机：也可以用下面的表格来表示这个自动机：   ’ ‘ +/- number other start start signed in_number end signed end end in_number end in_number end end in_number end end end end end end 接下来编程部分就非常简单了：只需要把上面这个状态转换表抄进代码即可。另外自动机也需要记录当前已经输入的数字，只要在 s' 为 in_number 时，更新输入的数字，即可最终得到输入的数字。class Solution { public int myAtoi(String str) { Automaton automaton = new Automaton(); int length = str.length(); for (int i = 0; i &lt; length; ++i) { automaton.get(str.charAt(i)); } return (int) (automaton.sign * automaton.ans); }}class Automaton { public int sign = 1; public long ans = 0; private String state = \"start\"; private Map&lt;String, String[]&gt; table = new HashMap&lt;String, String[]&gt;() { { put(\"start\", new String[]{\"start\", \"signed\", \"in_number\", \"end\"}); put(\"signed\", new String[]{\"end\", \"end\", \"in_number\", \"end\"}); put(\"in_number\", new String[]{\"end\", \"end\", \"in_number\", \"end\"}); put(\"end\", new String[]{\"end\", \"end\", \"end\", \"end\"}); } }; public void get(char c) { state = table.get(state)[get_col(c)]; if (\"in_number\".equals(state)) { ans = ans * 10 + c - '0'; ans = sign == 1 ? Math.min(ans, (long) Integer.MAX_VALUE) : Math.min(ans, -(long) Integer.MIN_VALUE); } else if (\"signed\".equals(state)) { sign = c == '+' ? 1 : -1; } } private int get_col(char c) { if (c == ' ') { return 0; } if (c == '+' || c == '-') { return 1; } if (Character.isDigit(c)) { return 2; } return 3; }}复杂度分析 时间复杂度：O(n)，其中 n 为字符串的长度。只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。 空间复杂度：O(1)。自动机的状态只需要常数空间存储。 " }, { "title": "6. Z 字形变换", "url": "/posts/6-zigzag-conversion/", "categories": "LeetCode, 字符串", "tags": "数据结构与算法", "date": "2022-07-06 07:31:00 +0000", "snippet": "问题描述将一个给定字符串 s 根据给定的行数 numRows，以从上往下、从左到右进行 Z 字形排列。s 由英文字母（小写和大写）、',' 和 '.' 组成。比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下：P A H NA P L S I I GY I R之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如:\"PAHNAPLSIIGYIR\"。请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows);示例 1：输入：s = \"PAYPALISHIRING\", numRows = 3输出：\"PAHNAPLSIIGYIR\"示例 2：输入：s = \"PAYPALISHIRING\", numRows = 4输出：\"PINALSIGYAHRPI\"解释：P I NA L S I GY A H RP I示例 3：输入：s = \"A\", numRows = 1输出：\"A\"方法一、利用二维矩阵模拟(不推荐)设 n 为字符串 s 的长度，r=numRows。对于 r=1（只有一行）或者 r≥n（只有一列）的情况，答案与 s 相同，可以直接返回 s。对于其余情况，考虑创建一个二维矩阵，然后在矩阵上按 Z 字形填写字符串 s，最后逐行扫描矩阵中的非空字符，组成答案。根据题意，当在矩阵上填写字符时，会向下填写 r 个字符，然后向右上继续填写 r−2 个字符，最后回到第一行，因此 Z 字形变换的周期 t=r+r-2=2r-2，每个周期会占用矩阵上的 1+r-2=r-1 列。因此有 ⌈t/n⌉ 个周期（最后一个周期视作完整周期），乘上每个周期的列数，得到矩阵的列数 c=⌈t/n⌉⋅(r−1)。创建一个 r 行 c 列的矩阵，然后遍历字符串 s 并按 Z 字形填写。具体来说，设当前填写的位置为 (x,y)，即矩阵的 x 行 y 列。初始 (x,y)=(0,0)，即矩阵左上角。若当前字符下标 i 满足 i mod t&lt;r−1，则向下移动，否则向右上移动。填写完成后，逐行扫描矩阵中的非空字符，组成答案。class Solution { public String convert(String s, int numRows) { int n = s.length(), r = numRows; if (r == 1 || r &gt;= n) { return s; } int t = r * 2 - 2; int c = (n / t + 1) * (r - 1); char[][] mat = new char[r][c]; for (int i = 0, x = 0, y = 0; i &lt; n; ++i) { mat[x][y] = s.charAt(i); if (i % t &lt; r - 1) { ++x; // 向下移动 } else { --x; ++y; // 向右上移动 } } StringBuffer ans = new StringBuffer(); for (char[] row : mat) { for (char ch : row) { if (ch != 0) { ans.append(ch); } } } return ans.toString(); }}复杂度分析 时间复杂度：O(r⋅n)，其中 r=numRows，n 为字符串 s 的长度。时间主要消耗在矩阵的创建和遍历上，矩阵的行数为 r，列数可以视为 O(n)。 空间复杂度：O(r⋅n)。矩阵需要 O(r⋅n) 的空间。 方法二、压缩矩阵空间方法一中的矩阵有大量的空间没有被使用，能否优化呢？注意到每次往矩阵的某一行添加字符时，都会添加到该行上一个字符的右侧，且最后组成答案时只会用到每行的非空字符。因此可以将矩阵的每行初始化为一个空列表，每次向某一行添加字符时，添加到该行的列表末尾即可。class Solution { public String convert(String s, int numRows) { int n = s.length(), r = numRows; if (r == 1 || r &gt;= n) { return s; } StringBuffer[] mat = new StringBuffer[r]; for (int i = 0; i &lt; r; ++i) { //对每一项初始化 mat[i] = new StringBuffer(); } for (int i = 0, x = 0, t = r * 2 - 2; i &lt; n; ++i) { mat[x].append(s.charAt(i)); if (i % t &lt; r - 1) { ++x; } else { --x; } } StringBuffer ans = new StringBuffer(); for (StringBuffer row : mat) { ans.append(row); } return ans.toString(); }}复杂度分析 时间复杂度：O(n)。 空间复杂度：O(n)。压缩后的矩阵需要 O(n) 的空间。 方法三、直接构造研究方法一中矩阵的每个非空字符会对应到 s 的哪个下标（记作idx），从而直接构造出答案。由于 Z 字形变换的周期为 t=2r-2，因此对于矩阵第一行的非空字符，其对应的 idx 均为 t 的倍数，即 idx≡0(modt)；同理，对于矩阵最后一行的非空字符，应满足 idx≡r−1(modt)。对于矩阵的其余行（行号设为 i），每个周期内有两个字符，第一个字符满足 idx≡i(modt)，第二个字符满足 idx≡t−i(modt)。0 0+t 0+2t 0+3t1 t-1 1+t 0+2t-1 1+2t 0+3t-1 1+3t2 t-2 2+t 0+2t-2 2+2t 0+3t-2 2+3t 3 3+t 3+2t 3+3tclass Solution {public: string convert(string s, int numRows) { int n = s.length(), r = numRows; if (r == 1 || r &gt;= n) { return s; } string ans; int t = r * 2 - 2; for (int i = 0; i &lt; r; ++i) { // 枚举矩阵的行 for (int j = 0; j + i &lt; n; j += t) { // 枚举每个周期的起始下标 ans += s[j + i]; // 当前周期的第一个字符 if (0 &lt; i &amp;&amp; i &lt; r - 1 &amp;&amp; j + t - i &lt; n) { ans += s[j + t - i]; // 当前周期的第二个字符 } } } return ans; }};复杂度分析 时间复杂度：O(n)，其中 n 为字符串 s 的长度。s 中的每个字符仅会被访问一次，因此时间复杂度为 O(n)。 空间复杂度：O(1)。返回值不计入空间复杂度。 " }, { "title": "7. 整数反转", "url": "/posts/7-zheng-shu-fan-zhuan/", "categories": "LeetCode, 数学", "tags": "数据结构与算法", "date": "2022-07-06 07:30:00 +0000", "snippet": "问题描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。输入: 123输出: 321输入: -123输出: -321输入: 120输出: 21 注意: 假设当前环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。Related Topics 数学方法一、数学记 rev 为翻转后的数字，为完成翻转，可以重复「弹出」x 的末尾数字，将其「推入」rev 的末尾，直至 x 为 0。要在没有辅助栈或数组的帮助下「弹出」和「推入」数字，可以使用如下数学方法：// 弹出 x 的末尾数字 digitdigit = x % 10x /= 10// 将数字 digit 推入 rev 末尾rev = rev * 10 + digit题目需要判断反转后的数字是否超过 32 位有符号整数的范围 [-2^{31},2^{31}-1]，例如 x=2123456789 反转后的 rev=9876543212&gt;2^31−1=2147483647，超过了 32 位有符号整数的范围。因此需要在「推入」数字之前，判断是否满足 −2^31≤rev⋅10+digit≤2^31−1。若该不等式不成立则返回 0。但是题目要求不允许使用 64 位整数，即运算过程中的数字必须在 32 位有符号整数的范围内，因此不能直接按照上述式子计算，需要另寻他路。class Solution { public int reverse(int x) { int rev = 0, digit = 0; while(x!=0){ if(rev &lt; Integer.MIN_VALUE/10 || rev &gt; Integer.MAX_VALUE/10){ return 0; } digit = x % 10; x /= 10; rev = rev * 10 + digit; } return rev; }}复杂度分析 时间复杂度：O(log∣x∣)。翻转的次数即 x 十进制的位数。 空间复杂度：O(1)。 " }, { "title": "5. 最长回文子串", "url": "/posts/5-zui-chang-hui-wen-zi-chuan/", "categories": "LeetCode, 字符串", "tags": "数据结构与算法", "date": "2022-07-06 07:30:00 +0000", "snippet": "问题描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。输入: \"cbbd\"输出: \"bb\"Related Topics 字符串 动态规划方法一、中心扩展算法对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。用 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串，状态转移方程：思路：枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。class Solution { public String longestPalindrome(String s) { int n = s.length(); if (s == null || n &lt; 1) { return \"\"; } //分别指向回文串的第一个字母和最后一个字母 int start = 0, end = 0; for(int i=0; i&lt;n; i++){ int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i+1); int len = Math.max(len1, len2); if(len &gt; end-start+1){ start = i - (len-1)/2; end = i + len/2; } } return s.substring(start, end+1); } public int expandAroundCenter(String s, int left, int right){ while(left&gt;=0 &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right)){ left--; right++; } return right-left-1; }}复杂度分析 时间复杂度：O(n^2) 空间复杂度：O(1) 方法二、动态规划用 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串，状态转移方程：public class Solution { public String longestPalindrome(String s) { int len = s.length(); if (len &lt; 2) { return s; } int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i &lt; len; i++) { dp[i][i] = true; } char[] charArray = s.toCharArray(); // 递推开始 // 先枚举子串长度 for (int L = 2; L &lt;= len; L++) { // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i &lt; len; i++) { // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j &gt;= len) { break; } if (charArray[i] != charArray[j]) { dp[i][j] = false; } else { //含有2或3个元素时，可以直接返回 if (j - i &lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i + 1][j - 1]; } } // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文， // 此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substring(begin, begin + maxLen); }}复杂度分析 时间复杂度：O(n^2)，其中 n 是字符串的长度。动态规划的状态总数为 O(n^2)，对于每个状态，需要转移的时间为 O(1)。 空间复杂度：O(n^2)，即存储动态规划状态需要的空间。 方法三、Manacher 算法复杂度为 O(n) 的 Manacher 算法。然而该算法十分复杂，一般不作为面试内容。题解" }, { "title": "4. 寻找两个正序数组的中位数", "url": "/posts/4-xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-06 06:30:00 +0000", "snippet": "问题描述给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。进阶：你能设计一个时间复杂度为 \\(O(log (m+n))\\) 的算法解决此问题吗？输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5输入：nums1 = [0,0], nums2 = [0,0]输出：0.00000输入：nums1 = [], nums2 = [1]输出：1.00000输入：nums1 = [2], nums2 = []输出：2.00000nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -106 &lt;= nums1[i], nums2[i] &lt;= 106 Related Topics 数组 二分查找 分治算法方法一、合并后查找给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种： 使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。 不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 0 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。 假设两个有序数组的长度分别为 m 和 n，上述两种思路的复杂度如何？ 第一种思路的时间复杂度是 O(m+n)，空间复杂度是 O(m+n)。 第二种思路虽然可以将空间复杂度降到 O(1)，但是时间复杂度仍是 O(m+n)。 方法二、二分查找如何把时间复杂度降低到 O(log(m+n)) 呢？如果对时间复杂度的要求有 log，通常都需要用到二分查找。根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2+1 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1。假设两个有序数组分别是 A 和 B。要找到第 k 个元素，可以比较 A[k/2−1] 和 B[k/2−1]，其中 / 表示整数除法。由于 A[k/2−1] 和 B[k/2−1] 的前面分别有 A[0..k/2−2] 和 B[0..k/2−2]，即 k/2−1 个元素，对于 A[k/2−1] 和 B[k/2−1] 中的较小值，最多只会有 (k/2−1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第 k 小的数了。因此可以归纳出三种情况： 如果 A[k/2−1]&lt;B[k/2−1]，则比 A[k/2−1] 小的数最多只有 A 的前 k/2−1 个数和 B 的前 k/2−1 个数，即比 A[k/2−1] 小的数最多只有 k−2 个，因此 A[k/2−1] 不可能是第 k 个数，A[0] 到 A[k/2−1] 也都不可能是第 k 个数，可以全部排除。 如果 A[k/2−1]&gt;B[k/2−1]，则可以排除 B[0] 到 B[k/2−1]。 如果 A[k/2−1]=B[k/2−1]，则可以归入第一种情况处理。 可以看到，比较 A[k/2−1] 和 B[k/2−1] 之后，可以排除 k/2 个不可能是第 k 小的数，查找范围缩小了一半。同时，将在排除后的新数组上继续进行二分查找，并且根据排除数的个数，减少 k 的值，这是因为排除的数都不大于第 k 小的数。🍒有以下三种情况需要特殊处理： 如果 A[k/2−1] 或者 B[k/2−1] 越界，那么可以选取对应数组中的最后一个元素。在这种情况下，必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k/2。 如果一个数组为空，说明该数组中的所有元素都被排除，可以直接返回另一个数组中第 k 小的元素。 如果 k=1，只要返回两个数组首元素的最小值即可。 明确 k：第 k 个小的元素，不是指的索引！class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int length1 = nums1.length, length2 = nums2.length; int totalLength = length1 + length2; if(totalLength % 2 ==1 ){ int midIndex = totalLength / 2; double median = getKthElement(nums1, nums2, midIndex+1); return median; }else{ int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2; double median = (getKthElement(nums1, nums2, midIndex1+1) + getKthElement(nums1, nums2, midIndex2+1))/2.0; return median; } } public int getKthElement(int[] nums1, int[] nums2, int k){ int length1 = nums1.length, length2 = nums2.length; int index1 = 0, index2 = 0; while(true){ //边界处理 if(index1==length1) return nums2[index2+k-1]; if(index2==length2) return nums1[index1+k-1]; if(k==1) return Math.min(nums1[index1], nums2[index2]); //正常情况下 int half = k/2; int newIndex1 = Math.min(index1+half, length1)-1; int newIndex2 = Math.min(index2+half, length2)-1; if(nums1[newIndex1]&lt;=nums2[newIndex2]){ k -= (newIndex1-index1+1); index1 = newIndex1 + 1; }else{ k -= (newIndex2-index2+1); index2 = newIndex2 + 1; } } }}复杂度分析 时间复杂度：O(log(m+n))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。初始时有 k=(m+n)/2 或 k=(m+n)/2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))。 空间复杂度：O(1)。 方法三、划分数组时间复杂度更低，O(log min(m,n)))题解class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { if (nums1.length &gt; nums2.length) { return findMedianSortedArrays(nums2, nums1); } int m = nums1.length; int n = nums2.length; int left = 0, right = m; // median1：前一部分的最大值 // median2：后一部分的最小值 int median1 = 0, median2 = 0; while (left &lt;= right) { // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1] // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1] int i = (left + right) / 2; int j = (m + n + 1) / 2 - i; // nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j] int nums_im1 = (i == 0 ? Integer.MIN_VALUE : nums1[i - 1]); int nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]); int nums_jm1 = (j == 0 ? Integer.MIN_VALUE : nums2[j - 1]); int nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]); if (nums_im1 &lt;= nums_j) { median1 = Math.max(nums_im1, nums_jm1); median2 = Math.min(nums_i, nums_j); left = i + 1; } else { right = i - 1; } } return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1; }}" }, { "title": "3. 无重复字符的最长子串", "url": "/posts/3-wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan/", "categories": "LeetCode, 字符串", "tags": "数据结构与算法", "date": "2022-07-06 05:30:00 +0000", "snippet": "问题描述给定一个字符串，请你找出其中【不含有重复字符】的最长子串的长度。示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 Related Topics 哈希表 双指针 字符串 Sliding Window注意：题目中并没有说只含字母，因此还可能含有数字、空格等字符。方法一、滑动窗口思路：找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。如： 以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb； 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb； 以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb； 以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb； 以 abca(b)cbb 开始的最长字符串为 abca(bc)bb； 以 abcab(c)bb 开始的最长字符串为 abcab(cb)b； 以 abcabc(b)b 开始的最长字符串为 abcabc(b)b； 以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。使用「滑动窗口」来解决问题：在左指针向右移动的时候，从哈希集合中移除一个字符，在右指针向右移动的时候，往哈希集合中添加一个字符。class Solution { public int lengthOfLongestSubstring(String s) { // 哈希集合，记录每个字符是否出现过 Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int n = s.length(); if(n==0) return 0; // 右指针 int rk = 0, ans = 0; for(int i=0; i&lt;n; i++){ if(i!=0){ //移除第i-1个字符 set.remove(s.charAt(i - 1)); } while(rk&lt;n &amp;&amp; !set.contains(s.charAt(rk))){ set.add(s.charAt(rk)); rk++; } ans = Math.max(ans, rk-i); } return ans; }} 注意 Set 集合 contains 方法的拼写" }, { "title": "2. 两数相加", "url": "/posts/2-liang-shu-xiang-jia/", "categories": "LeetCode, 链表", "tags": "数据结构与算法", "date": "2022-07-06 04:30:00 +0000", "snippet": "问题描述给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 [逆序] 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807Related Topics 链表 数学方法一、模拟思路： 由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。 同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。和为 n1+n2+carry；其中，答案链表处相应位置的数字为 (n1+n2+carry)%10，而新的进位值为 (n1+n2+carry)/10。 如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0。 此外，如果链表遍历结束后，有 carry&gt;0，还需要在答案链表的后面附加一个节点，节点的值为 carry。1) 头头节点class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int carry = 0; ListNode head = new ListNode(); ListNode curr = head; while(l1!=null || l2!=null){ int node1 = (l1==null)? 0: l1.val; int node2 = (l2==null)? 0: l2.val; int v = (node1 + node2 + carry) % 10; carry = (node1 + node2 + carry) / 10; curr.next = new ListNode(v); curr = curr.next; if(l1!=null) l1 = l1.next; if(l2!=null) l2 = l2.next; } //!!! if(carry&gt;0) curr.next = new ListNode(carry); return head.next; }}2) 头节点class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode head = null, tail = null; int carry = 0; while(l1!=null || l2!=null){ int n1 = l1!=null? l1.val: 0; int n2 = l2!=null? l2.val: 0; int sum = n1 + n2 + carry; if(head==null){ head = tail = new ListNode(sum % 10); }else{ tail.next = new ListNode(sum % 10); tail = tail.next; } carry = sum/10; if(l1!=null) l1 = l1.next; if(l2!=null) l2 = l2.next; } if(carry&gt;0) tail.next = new ListNode(carry); return head; }}复杂度分析 时间复杂度：O(max(m,n))，其中 m,n 为两个链表的长度。要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。 空间复杂度：O(max(m,n))。答案链表的长度最多为较长链表的长度 +1。方法二、递归class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { return recursive(l1, l2, 0); } private ListNode recursive(ListNode l1, ListNode l2, int carry) { if (l1 == null &amp;&amp; l2 == null &amp;&amp; carry == 0) { // 递归结束条件 return null; } int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; int curSum = l1Val + l2Val + carry; ListNode curNode = new ListNode(curSum % 10); curNode.next = recursive(l1 == null ? null : l1.next, l2 == null ? null : l2.next, curSum / 10); return curNode; }}" }, { "title": "1. 两数之和", "url": "/posts/1-liang-shu-zhi-he/", "categories": "LeetCode, 数组", "tags": "数据结构与算法", "date": "2022-07-05 03:33:00 +0000", "snippet": "问题描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那【两个】整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]Related Topics 数组 哈希表方法一、哈希表算法：使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。创建一个哈希表，对于每一个 x，首先查询哈希表中是否存在 target - x，存在则返回结果。不存在则将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。class Solution { public int[] twoSum(int[] nums, int target) { int len = nums.length; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;len; i++){ if(map.containsKey(target-nums[i])){ return new int[]{map.get(target-nums[i]),i}; } map.put(nums[i],i); } return new int[0]; //或return new int[]{}; }}复杂度分析 时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，可以 O(1) 地寻找 target - x。 空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。 方法二、暴力枚举【不推荐】思路：枚举数组中的每一个数 x，寻找数组中是否存在 target - x。元素不能被重复使用，只需要在 x 后面的元素中寻找 target - x。class Solution { public int[] twoSum(int[] nums, int target) { int len = nums.length; for(int i=0; i&lt;len; i++){ for(int j=i+1; j&lt;len; j++){ if(nums[i]+nums[j]==target) return new int[]{i,j}; } } return new int[0]; }}复杂度分析 时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。 空间复杂度：O(1)。" }, { "title": "0. LeetCode 目录", "url": "/posts/0-catalogue/", "categories": "LeetCode", "tags": "数据结构与算法", "date": "2022-07-05 00:30:00 +0000", "snippet": "1-100 题目 题解 关注程度 1. 两数之和 题解 okkk " } ]
